Target:
  name: RISCV
  infos: [InstInfo, InstSelInfo]
InstInfo: {
    # Templates
    Templates: {
        Rtype: {
            # format: "{mnem} {rd}, {rs1}, {rs2}",
            format: [mnem, " ", 0, ", ", 1, ", ", 2],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: rs1, type: GPR, flag: Use },
                2: { name: rs2, type: GPR, flag: Use },
              },
          },
        Itype: {
            # format: "$mnem $rd, $rs1, $imm",
            format: [mnem, " ", 0, ", ", 1, ", ", 2],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: rs1, type: GPR, flag: Use },
                2: { name: imm, type: IMM12, flag: Metadata },
              },
          },
        Stype: {
            # format: "$mnem $rs2, $offset($rs1)",
            format: [mnem, " ", 0, ", ", 1, "(", 2, ")"],
            operands:
              {
                0: { name: rs2, type: GPR, flag: Use },
                1: { name: offset, type: IMM12, flag: Metadata },
                2: { name: rs1, type: GPR, flag: Use }, # BaseLike
              },
          },
        Ltype:
          {
            format: [mnem, " ", 0, ", ", 1, "(", 2, ")"],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: offset, type: IMM12, flag: Metadata },
                2: { name: rs1, type: GPR, flag: Use }, # BaseLike
              },
          },
        Utype: {
            # format: "$mnem $rd, $imm",
            format: [mnem, " ", 0, ", ", 1],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: imm, type: IMM20, flag: Metadata },
              },
          },
        # for Pseudos
        # branch Btype-Itype offset-imm
        Branches:
          {
            format: ["mnem", " ", 0, ", ", 1, ", ", 2, " # ", 3],
            operands:
              {
                0: { name: rs1, type: GPR, flag: Use },
                1: { name: rs2, type: GPR, flag: Use },
                2: { name: target, type: reloc, flag: Metadata },
                3: { name: prob, type: prob, flag: Metadata },
              },
            flag: [Branch, Terminator],
            instances: [
                { name: BEQ, mnem: "beq" }, # ==
                { name: BNE, mnem: "bne" }, # !=
                { name: BLE, mnem: "ble" }, # <=
                { name: BGT, mnem: "bgt" }, # >
                { name: BLT, mnem: "blt" }, # <
                { name: BGE, mnem: "bge" }, # >=
                { name: BLEU, mnem: "bleu" }, # unsigned <=
                { name: BGTU, mnem: "bgtu" }, # unsigned >
                { name: BLTU, mnem: "bltu" }, # unsigned <
                { name: BGEU, mnem: "bgeu" }, # unsigned >=
              ],
          },
        FRType: {
            # $mnem $rd:FPR[Def], $rs1:FPR[Use], $rs2:FPR[Use]
            format: [mnem, " ", 0, ", ", 1, ", ", 2],
            operands:
              {
                0: { name: rd, type: FPR, flag: Def },
                1: { name: rs1, type: FPR, flag: Use },
                2: { name: rs2, type: FPR, flag: Use },
              },
            instances: [
                { name: FADD_S, mnem: "fadd.s" }, # f[rd] = f[rs1] + f[rs2]
                { name: FSUB_S, mnem: "fsub.s" }, # f[rd] = f[rs1] - f[rs2]
                { name: FMUL_S, mnem: "fmul.s" }, # f[rd] = f[rs1] * f[rs2]
                { name: FDIV_S, mnem: "fdiv.s" }, # f[rd] = f[rs1] / f[rs2]
                { name: FMIN_S, mnem: "fmin.s" }, # f[rd] = min(f[rs1], f[rs2])
                { name: FMAX_S, mnem: "fmax.s" }, # f[rd] = max(f[rs1], f[rs2])
              ],
          },

        FMAType: {
            # $mnem $rd:FPR[Def], $rs1:FPR[Use], $rs2:FPR[Use], $rs3:FPR[Use]
            format: [mnem, " ", 0, ", ", 1, ", ", 2, ", ", 3],
            operands:
              {
                0: { name: rd, type: FPR, flag: Def },
                1: { name: rs1, type: FPR, flag: Use },
                2: { name: rs2, type: FPR, flag: Use },
                3: { name: rs3, type: FPR, flag: Use },
              },
            instances: [
                { name: FMADD_S, mnem: "fmadd.s" }, # f[rd] = (f[rs1] * f[rs2]) + f[rs3]
                { name: FMSUB_S, mnem: "fmsub.s" }, # f[rd] = (f[rs1] * f[rs2]) - f[rs3]
                { name: FNMADD_S, mnem: "fnmadd.s" }, # f[rd] = -(f[rs1] * f[rs2]) + f[rs3]
                { name: FNMSUB_S, mnem: "fnmsub.s" }, # f[rd] = -(f[rs1] * f[rs2]) - f[rs3]
              ],
          },
        FFType: {
            # $mnem $rd:FPR[Def], $rs1:FPR[Use]
            format: [mnem, " ", 0, ", ", 1],
            operands:
              {
                0: { name: rd, type: FPR, flag: Def },
                1: { name: rs1, type: FPR, flag: Use },
              },
            instances: [
                { name: FNEG_S, mnem: "fneg.s" }, # f[rd] = -f[rs1]
                { name: FABS_S, mnem: "fabs.s" }, # f[rd] = abs(f[rs1])
                { name: FMV_S, mnem: "fmv.s" }, # f[rd] = f[rs1]
                { name: FSQRT_S, mnem: "fsqrt.s" }, # f[rd] = sqrt(f[rs1])
                { name: FSGNJ_S, mnem: "fsgnj.s" }, # f[rd] = {f[rs2][31], f[rs1][30:0]}

              ],
          },
        FIFType: {
            # .W.S
            # $mnem $rd:GPR[Def], $rs1:FPR[Use]
            format: [mnem, " ", 0, ", ", 1],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: rs1, type: FPR, flag: Use },
              },
            instances: [
                { name: FCLASS_S, mnem: "fclass.s" }, # x[rd] = classify_s(f[rs1])
                { name: FMV_X_W, mnem: "fmv.x.w" }, # x[rd] = sext(f[rs1][31:0])
                # { name: FCVT_W_S, mnem: "fcvt.w.s" }, # x[rd] = sext(s32_f32(f[rs1])), default rounding mode RNE
                { name: FCVT_WU_S, mnem: "fcvt.wu.s" }, # x[rd] = sext(u32_f32(f[rs1]))
              ],
          },
        FFIType: {
            # .S.W
            # $mnem $rd:FPR[Def], $rs1:GPR[Use]
            format: [mnem, " ", 0, ", ", 1],
            operands:
              {
                0: { name: rd, type: FPR, flag: Def },
                1: { name: rs1, type: GPR, flag: Use },
              },
            instances: [
                { name: FMV_W_X, mnem: "fmv.w.x" }, # f[rd] = x[rs1][31:0]
                { name: FCVT_S_W, mnem: "fcvt.s.w" }, # f[rd] = f32_s32(x[rs1])
                { name: FCVT_S_WU, mnem: "fcvt.s.wu" }, # f[rd] = f32_u32(x[rs1])
              ],
          },
        FIFFType: {
            # $mnem $rd:GPR[Def], $rs1:FPR[Use], $rs2:FPR[Use]
            format: [mnem, " ", 0, ", ", 1, ", ", 2],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: rs1, type: FPR, flag: Use },
                2: { name: rs2, type: FPR, flag: Use },
              },
            instances: [
                { name: FEQ_S, mnem: "feq.s" }, # x[rd] = f[rs1] == f[rs2]
                { name: FLT_S, mnem: "flt.s" }, # x[rd] = f[rs1] < f[rs2]
                { name: FLE_S, mnem: "fle.s" }, # x[rd] = f[rs1] <= f[rs2]
              ],
          },
        FIFRTZType: {
            # $mnem $rd:GPR[Def], $rs1:FPR[Use], rtz
            format: [mnem, " ", 0, ", ", 1, ", rtz"],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: rs1, type: FPR, flag: Use },
              },
            instances: [
                { name: FCVT_W_S, mnem: "fcvt.w.s" }, # x[rd] = sext(s32_f32(f[rs1])), rounding mode RTZ
              ],
          },
      },
    # Instances
    Instances: {
        # RV32I Base Integer Instructions
        # RRR
        ADD: { mnem: "add", template: Rtype },
        ADDW: { mnem: "addw", template: Rtype }, # RV64
        SUB: { mnem: "sub", template: Rtype },
        SUBW: { mnem: "subw", template: Rtype }, # RV64
        XOR: { mnem: "xor", template: Rtype },
        OR: { mnem: "or", template: Rtype },
        AND: { mnem: "and", template: Rtype },
        SLL: { mnem: "sll", template: Rtype },
        SRL: { mnem: "srl", template: Rtype },
        SRA: { mnem: "sra", template: Rtype },
        SLT: { mnem: "slt", template: Rtype },
        SLTU: { mnem: "sltu", template: Rtype },
        # RII
        ADDI: { mnem: "addi", template: Itype },
        XORI: { mnem: "xori", template: Itype },
        ORI: { mnem: "ori", template: Itype },
        ANDI: { mnem: "andi", template: Itype },
        SLTI: { mnem: "slti", template: Itype },
        SLTIU: { mnem: "sltiu", template: Itype },
        # RII-shift
        SLLI:
          {
            mnem: "slli",
            template: Itype,
            operands: { imm: { type: UIMM6, flag: Metadata } },
          },
        SRLI:
          {
            mnem: "srli",
            template: Itype,
            operands: { imm: { type: UIMM6, flag: Metadata } },
          },
        SRAI:
          {
            mnem: "srai",
            template: Itype,
            operands: { imm: { type: UIMM6, flag: Metadata } },
          },
        # Load
        LB: { mnem: "lb", template: Ltype, flag: [Load] },
        LH: { mnem: "lh", template: Ltype, flag: [Load] },
        LW: { mnem: "lw", template: Ltype, flag: [Load] },
        LBU: { mnem: "lbu", template: Ltype, flag: [Load] },
        LHU: { mnem: "lhu", template: Ltype, flag: [Load] },
        LD: { mnem: "ld", template: Ltype, flag: [Load] }, # RV64
        # Store
        SB: { mnem: "sb", template: Stype, flag: [Store] },
        SH: { mnem: "sh", template: Stype, flag: [Store] },
        SW: { mnem: "sw", template: Stype, flag: [Store] },
        SD: { mnem: "sd", template: Stype, flag: [Store] }, # RV64
        JAL:
          {
            format: ["jal", " ", 0],
            operands: { 0: { name: target, type: reloc, flag: Metadata } },
            flag: [Call],
          },
        J:
          {
            format: ["j", " ", 0],
            operands: { 0: { name: target, type: reloc, flag: Metadata } },
            flag: [Branch, Terminator, NoFallThrough],
          },
        RET:
          {
            format: ["ret"],
            operands: {},
            flag: [Return, Terminator, NoFallThrough],
          },
        # RIU lui, auipc
        LUI: { mnem: "lui", template: Utype, flag: [LoadConstant] },
        # auipc rd, imm: x[rd] = pc + sext(imm[31:12] << 12)
        AUIPC: { mnem: "auipc", template: Utype, flag: [PCRel, LoadConstant] },

        # lla rd, symbol: x[rd] = &symbol, Presudo, Load Local Address
        # ->
        # auipc rd, symbol[31:12]
        # addi rd, rd, symbol[11:0]
        LLA:
          {
            format: ["lla", " ", 0, ", ", 1],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: symbol, type: reloc, flag: Metadata },
              },
          },
        # RV32M Multiply Extension
        MUL: { mnem: "mul", template: Rtype },
        MULW: { mnem: "mulw", template: Rtype }, # RV64I
        MULH: { mnem: "mulh", template: Rtype },
        MULHSU: { mnem: "mulhsu", template: Rtype },
        MULHU: { mnem: "mulhu", template: Rtype },
        DIV: { mnem: "div", template: Rtype },
        DIVW: { mnem: "divw", template: Rtype }, # RV64I
        DIVU: { mnem: "divu", template: Rtype },
        REM: { mnem: "rem", template: Rtype },
        REMW: { mnem: "remw", template: Rtype }, # RV64I
        REMU: { mnem: "remu", template: Rtype },

        # RV32A Atomic Instructions
        LR: { mnem: "lr.w", template: Rtype }, # Load Reserved
        SC: { mnem: "sc.w", template: Rtype }, # Store Conditional
        AMOSWAP: { mnem: "amoswap.w", template: Rtype },
        AMOADD: { mnem: "amoadd.w", template: Rtype },
        AMOAND: { mnem: "amoand.w", template: Rtype },
        AMOOR: { mnem: "amoor.w", template: Rtype },
        AMOXOR: { mnem: "amoxor.w", template: Rtype },
        # RV32F Single-Precision Floating-Point Instructions
        ## Single-Precision Floating-Point Load and Store Instructions
        FLW:
          {
            format: ["flw", " ", 0, ", ", 1, "(", 2, ")"],
            operands:
              {
                0: { name: rd, type: FPR, flag: Def },
                1: { name: offset, type: IMM12, flag: Metadata },
                2: { name: rs1, type: BaseLike, flag: Use }, # BaseLike
              },
            flag: [Load],
          },
        FSW:
          {
            format: ["fsw", " ", 0, ", ", 1, "(", 2, ")"],
            operands:
              {
                0: { name: rs2, type: FPR, flag: Use },
                1: { name: offset, type: IMM12, flag: Metadata },
                2: { name: rs1, type: BaseLike, flag: Use }, # BaseLike
              },
            flag: [Store],
          },
        ## Single-Precision Floating-Point Computational Instructions
        ## Single-Precision Floating-Point Conversion and Move Instructions
        ## Single-Precision Floating-Point Compare Instructions
        ## Single-Precision Floating-Point Classify Instruction
        # Pseudos
        # nop
        LoadImm12:
          {
            format: ["li", " ", 0, ", ", 1],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: imm, type: NonZeroImm12, flag: Metadata },
              },
            flag: [LoadConstant],
          },
        LoadImm32:
          {
            format: ["li", " ", 0, ", ", 1],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: imm, type: NonZeroImm32, flag: Metadata },
              },
            flag: [LoadConstant],
          },
        LoadImm64:
          {
            format: ["li", " ", 0, ", ", 1],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: imm, type: NonZeroImm64, flag: Metadata },
              },
            flag: [LoadConstant],
          },
        MV:
          {
            format: ["mv", " ", 0, ", ", 1],
            operands:
              {
                0: { name: rd, type: GPR, flag: Def },
                1: { name: rs1, type: GPR, flag: Use },
              },
            flag: [RegCopy],
          },
      },
  }
InstSelInfo: {
    # templates
    Templates: {},
    # instances
    Instances: [
        {
          # LoadGlobalAddress dst[INTREG], reloc[RELOC]
          pattern: { name: InstLoadGlobalAddress, dst: $dst, addr: $addr },
          replace: {
              name: LLA, # lla rd, symbol
              rd: "getVRegAs(ctx, $dst)",
              symbol: $addr,
            },
        },
        {
          pattern: { name: InstLoadGlobalAddress, dst: $dst, addr: $addr },
          replace:
            {
              name: ADDI,
              rd: $dst,
              rs1:
                {
                  name: AUIPC,
                  rd: "getVRegAs(ctx, $dst)",
                  imm: getHighBits($addr),
                },
              imm: getLowBits($addr),
            },
        },

        # { pattern: { name: InstLoadStackObjectAddr } },

        # load and store
        {
          # InstLoad
          pattern: {
              name: InstLoad,
              dst: $dst,
              addr: $addr,
              ## align: $align,
              predicate: "selectAddrOffset($addr, ctx, [$base], [$offset])",
            },
          replace: {
              name: getLoadOpcode($dst),
              ref: LB,
              rd: $dst,
              rs1: $base,
              offset: $offset, # align: $align, # todo, process load inst info
            },
        },
        {
          # InstStore
          pattern: {
              name: InstStore,
              addr: $addr, # align: $align,
              src: $src,
              predicate: "isOperandVRegORISAReg($src) && selectAddrOffset($addr, ctx, [$base], [$offset])",
            },
          replace:
            {
              name: getStoreOpcode($src),
              ref: SB,
              rs2: $src,
              rs1: $base,
              offset: $offset,
            },
        },
        # Control Flow
        {
          pattern: { name: InstJump, target: $target },
          replace: { name: J, target: $target },
        },
        {
          # Return
          pattern: { name: InstReturn },
          replace: { name: RET },
        },
        {
          # name list
          pattern:
            {
              name: [InstLoadImm, InstLoadImmToReg],
              dst: $dst,
              imm: $imm,
              predicate: isZero($imm),
            },
          replace: { name: MV, rd: $dst, rs1: getZero($dst) },
        },
        {
          pattern:
            {
              name: [InstLoadImm, InstLoadImmToReg],
              dst: $dst,
              imm: $imm,
              predicate: isOperandNonZeroImm12($imm),
            },
          replace: { name: LoadImm12, rd: $dst, imm: $imm },
        },
        {
          pattern:
            {
              name: [InstLoadImm, InstLoadImmToReg],
              dst: $dst,
              imm: $imm,
              predicate: isOperandNonZeroImm32($imm),
            },
          replace: { name: LoadImm32, rd: $dst, imm: $imm },
        },
        # InstAdd
        {
          pattern:
            {
              name: InstAdd,
              dst: $dst,
              src1: { name: InstShl, src1: $src1, src2: $imm },
              src2: $src2,
              predicate: "isOperandIReg($dst) && isOperandIReg($src1) && isOperandIReg($src2) && ($imm).isImm() && ($imm).imm() == 1",
            },
          replace: { name: SH1ADD, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          # imm = 1,2,3
          pattern:
            {
              name: InstAdd,
              dst: $dst,
              src1: $src1,
              src2: { name: InstShl, dst: $dst, src1: $src1, src2: $imm },
              predicate: "isOperandIReg($dst) && isOperandIReg($src1) && isOperandIReg($src2) && ($imm).isImm() && ($imm).imm() == 1",
            },
          replace: { name: SH1ADD, rd: $src1, rs1: $src2, rs2: $src1 },
        },
        {
          pattern:
            {
              name: InstAdd,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI64($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: ADD, rd: $dst, rs1: $src1, rs2: $src2 },
        },

        {
          pattern:
            {
              name: InstAdd,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI32($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: ADDW, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstSub
        {
          pattern:
            {
              name: InstSub,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI64($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: SUB, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern:
            {
              name: InstSub,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI32($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: SUBW, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstMul
        {
          pattern:
            {
              name: InstMul,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI64($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: MUL, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern:
            {
              name: InstMul,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI32($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: MULW, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstUDiv
        {
          pattern:
            {
              name: InstUDiv,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI64($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: DIVU, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern:
            {
              name: InstUDiv,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI32($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: DIVUW, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstURem
        {
          pattern:
            {
              name: InstURem,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI64($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: REMU, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern:
            {
              name: InstURem,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI32($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: REMUW, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        #! BinaryRegOpcode???
        {
          pattern:
            {
              name: [InstAnd, InstOr, InstXor],
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace:
            {
              name: getIntegerBinaryRegOpcode(rootOpcode),
              ref: AND,
              rd: $dst,
              rs1: $src1,
              rs2: $src2,
            },
        },
        # BinaryImm
        {
          pattern:
            {
              name: [InstAnd, InstOr, InstXor],
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandIReg($src1) && isOperandImm12($src2),
            },
          replace:
            {
              name: getIntegerBinaryImmOpcode(rootOpcode),
              ref: ANDI,
              rd: $dst,
              rs1: $src1,
              imm: $src2,
            },
        },
        # InstShl
        {
          pattern:
            {
              name: InstShl,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI64($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: SLL, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern:
            {
              name: InstShl,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI32($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: SLLW, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstLShr
        {
          pattern:
            {
              name: InstLShr,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI64($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: SRL, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern:
            {
              name: InstLShr,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI32($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: SRLW, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstAShr
        {
          pattern:
            {
              name: InstAShr,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI64($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: SRA, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern:
            {
              name: InstAShr,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI32($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: SRAW, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstSDiv
        {
          pattern:
            {
              name: InstSDiv,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI64($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: DIV, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern:
            {
              name: InstSDiv,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI32($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: DIVW, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstSRem
        {
          pattern:
            {
              name: InstSRem,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI64($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: REM, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern:
            {
              name: InstSRem,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandI32($dst) && isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: REMW, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstMin
        {
          pattern:
            {
              name: InstSMin,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandIReg($src1) && isOperandIReg($src2),
            },

          replace: { name: MIN, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstMax
        {
          pattern:
            {
              name: InstSMax,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              predicate: isOperandIReg($src1) && isOperandIReg($src2),
            },
          replace: { name: MAX, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # InstAbs
        {
          pattern:
            {
              name: InstAbs,
              dst: $dst,
              src: $src,
              predicate: isOperandIReg($src) && isOperandI32($dst),
            },
          replace:
            {
              name: MAX,
              rd: $dst,
              rs1:
                {
                  name: SUBW,
                  rd: "getVRegAs(ctx, $dst)",
                  rs1: getZero($dst),
                  rs2: $src,
                },
              rs2: $src,
            },
        },
        #! InstICmp: SLT, SLTU, SLTI, SLTIU: TODO
        {
          # ICmpSignedLessThan dst, src1, src2 -> SLT dst, src1, src2
          # src1 < src2 -> src1 < src2
          pattern:
            {
              name: InstICmp,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              op: $op,
              predicate: "isOperandIReg($src1) && isOperandIReg($src2) && isCompareOp($op, CompareOp::ICmpSignedLessThan)",
            },
          replace: { name: SLT, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          # ICmpSignedGreaterEqual dst, src1, src2 -> not(SLT dst, src1, src2)
          # src1 >= src2 -> not(src1 < src2)
          # xori dst, src, 1 -> not(src)
          pattern:
            {
              name: InstICmp,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              op: $op,
              predicate: "isOperandIReg($src1) && isOperandIReg($src2) && isCompareOp($op, CompareOp::ICmpSignedGreaterEqual)",
            },
          replace:
            {
              name: XORI,
              rd: $dst,
              rs1:
                {
                  name: SLT,
                  rd: "getVRegAs(ctx, $dst)",
                  rs1: $src1,
                  rs2: $src2,
                },
              imm: getOne($src2),
            },
        },
        # SLTU
        {
          # ICmpUnsignedLessThan dst, src1, src2 -> SLTU dst, src1, src2
          # src1 < src2 -> src1 < src2
          pattern:
            {
              name: InstICmp,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              op: $op,
              predicate: "isOperandIReg($src1) && isOperandIReg($src2) && isCompareOp($op, CompareOp::ICmpUnsignedLessThan)",
            },
          replace: { name: SLTU, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          # ICmpSignedGreaterThan dst, src1, src2 -> SLT dst, src2, src1
          # src1 > src2 -> src2 < src1
          pattern:
            {
              name: InstICmp,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              op: $op,
              predicate: "isOperandIReg($src1) && isOperandIReg($src2) && isCompareOp($op, CompareOp::ICmpSignedGreaterThan)",
            },
          replace: { name: SLT, rd: $dst, rs1: $src2, rs2: $src1 },
        },
        {
          # ICmpUnsignedGreaterThan dst, src1, src2 -> SLTU dst, src2, src1
          # src1 > src2 -> src2 < src1
          pattern:
            {
              name: InstICmp,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              op: $op,
              predicate: "isOperandIReg($src1) && isOperandIReg($src2) && isCompareOp($op, CompareOp::ICmpUnsignedGreaterThan)",
            },
          replace: { name: SLTU, rd: $dst, rs1: $src2, rs2: $src1 },
        },
        {
          # ICmpEqual dst, src1, 0 -> SLTIU dst, src1, 1
          # src1 == 0 -> sltiu dst, src1, 1
          pattern:
            {
              name: InstICmp,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              op: $op,
              predicate: "isOperandIReg($src1) && isZero($src2) && isCompareOp($op, CompareOp::ICmpEqual)",
            },
          replace: { name: SLTIU, rd: $dst, rs1: $src1, imm: getOne($src2) },
        },
        {
          # ICmpNotEqual dst, src1, 0 -> SLTU dst, 0, src1
          # src1 != 0 -> sltu dst, zero, src1
          pattern:
            {
              name: InstICmp,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              op: $op,
              predicate: "isOperandIReg($src1) && isZero($src2) && isCompareOp($op, CompareOp::ICmpNotEqual)",
            },
          replace: { name: SLTU, rd: $dst, rs1: getZero($src2), rs2: $src1 },
        },
        {
          # x<=y -> !(y<x)
          pattern:
            {
              name: InstICmp,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              op: $op,
              predicate: "isOperandIReg($src1) && isOperandIReg($src2) && isCompareOp($op, CompareOp::ICmpSignedLessEqual)",
            },
          replace:
            {
              name: XORI,
              rd: $dst,
              rs1:
                {
                  name: SLT,
                  rd: "getVRegAs(ctx, $dst)",
                  rs1: $src2,
                  rs2: $src1,
                },
              imm: getOne($src2),
            },
        },
        # branch
        {
          pattern:
            {
              name: InstBranch,
              cond: $cond,
              target: $target,
              prob: $prob,
              predicate: isOperandIReg($cond),
            },
          replace:
            {
              name: BNE,
              rs1: $cond,
              rs2: getZero($cond),
              target: $target,
              prob: $prob,
            },
        },
        # float
        {
          pattern: { name: InstF2S, dst: $dst, src: $src },
          replace: { name: FCVT_W_S, rd: $dst, rs1: $src },
        },
        {
          pattern: { name: InstS2F, dst: $dst, src: $src },
          replace: { name: FCVT_S_W, rd: $dst, rs1: $src },
        },
        {
          # FCmp
          pattern:
            {
              name: InstFCmp,
              dst: $dst,
              src1: $src1,
              src2: $src2,
              op: $op,
              predicate: "selectFCmpOpcode($op, $src1, $src2, [$outlhs], [$outrhs], [$cmpOpcode])",
            },
          replace:
            {
              name: static_cast<uint32_t>(($cmpOpcode).imm()),
              ref: FLT_S,
              rd: $dst,
              rs1: $outlhs,
              rs2: $outrhs,
            },
        },
        {
          pattern: { name: InstFNeg, dst: $dst, src: $src },
          replace: { name: FNEG_S, rd: $dst, rs1: $src },
        },
        {
          pattern: { name: InstFAdd, dst: $dst, src1: $src1, src2: $src2 },
          replace: { name: FADD_S, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern: { name: InstFSub, dst: $dst, src1: $src1, src2: $src2 },
          replace: { name: FSUB_S, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern: { name: InstFMul, dst: $dst, src1: $src1, src2: $src2 },
          replace: { name: FMUL_S, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        {
          pattern: { name: InstFDiv, dst: $dst, src1: $src1, src2: $src2 },
          replace: { name: FDIV_S, rd: $dst, rs1: $src1, rs2: $src2 },
        },
        # { pattern: {
        #   name: [InstFAdd, InstFSub, InstFMul, InstFDiv],
        # } },
        {
          pattern:
            {
              name: InstZExt,
              dst: $dst,
              src: $src,
              predicate: isOperandBoolReg($src),
            },
          replace: { name: InstCopy, dst: $dst, src: $src },
        },
      ],
  }

ScheduleModel:
  #
  { sifive_u74: {
        #
        Classes: {
            #
            IntegerArithmetic: [
                ADDI,
                SLTI,
                SLTIU,
                ANDI,
                ORI,
                XORI,
                SLLI,
                SRLI,
                SRAI,
                LUI,
                AUIPC,
                ADD,
                SLT,
                SLTU,
                AND,
                OR,
                XOR,
                SLL,
                SRL,
                SUB,
                SRA,
                # ADDIW,
                # SLLIW,
                # SRLIW,
                # SRAIW,
                ADDW,
                SUBW,
                # SLLW,
                # SRLW,
                # SRAW,
                # ADD_UW,
                # SLLI_UW,
                # ANDN,
                # ORN,
                # XNOR,
                # MIN,
                # MINU,
                # MAX,
                # MAXU,
                # SEXT_B,
                # SEXT_H,
                # SEXT_W,
                # ZEXT_H,
                # ZEXT_W,
                LoadImm12,
                # MoveGPR,
                MV,
                InstLoadStackObjectAddr,
                InstCopy,
                InstCopyFromReg,
                InstCopyToReg,
                # add by hhw, need check
                LLA,
              ],
            SlowLoadImm: [
                InstLoadImm,
                LoadImm32,
                LoadImm64,
                # LoadImm64Complex
              ],
            # IntegerArithmeticLateB:
            #   [ROL, ROLW, ROR, RORI, RORIW, RORW, CLZ, CLZW, CTZ, CTZW, ORC_B],
            # IntegerArithmeticEarlyB: [],
            # IntegerArithmeticLateAB: [],
            # IntegerArithmeticEarlyLateB: [],
            Branch: [
                JAL,
                RET,
                BEQ,
                BNE,
                BLT,
                BLE,
                BGT,
                BGE,
                BLTU,
                BLEU,
                BGTU,
                BGEU,
                J,
                # JR,
                # UNIMP,
              ],
            LoadStore: [
                LB,
                LH,
                LW,
                LBU,
                LHU,
                SB,
                SH,
                SW,
                LD,
                # LWU,
                SD,
                InstStoreRegToStack,
                # AMOADD_W,
              ],
            Multi: [MUL, MULH, MULHSU, MULHU, MULW],
            DivRem: [
                DIV,
                # DIVU,
                REM,
                REMU,
                # DIVUW,
                # REMUW,
              ],
            SDivRemW: [DIVW, REMW],
            FPCycle1: [FMV_X_W],
            FPCycle2:
              [
                FNEG_S,
                FCVT_S_W,
                FCVT_S_WU,
                FMV_S,
                FMV_W_X,
                FMIN_S,
                FMAX_S,
                FSGNJ_S,
                FABS_S,
              ],
            FPCycle4: [FEQ_S, FLT_S, FLE_S, FCVT_W_S, FCVT_WU_S],
            FPCycle5:
              [FADD_S, FSUB_S, FMUL_S, FMADD_S, FMSUB_S, FNMADD_S, FNMSUB_S],
            FPDiv: [FDIV_S],
            FPLoadStore: [FLW, FSW],
            GeneralLoad: [InstLoadRegFromStack],
          },
      } }
