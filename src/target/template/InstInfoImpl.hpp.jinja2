// Automatically generated file, do not edit!

#pragma once
#include "mir/mir.hpp"
#include "mir/instinfo.hpp"
#include "target/{{target_name.lower()}}/InstInfoDecl.hpp"

TARGET_NAMESPACE_BEGIN

{%for name, info in insts.items() %}
class {{target_name}}InstInfo{{name}} final: public InstInfo {
public:
    {{target_name}}InstInfo{{name}}() = default;

    void print(std::ostream& out, MIRInst& inst, bool comment) {        
        out 
        {%- for part in info.format -%}
            <<
            {%- if part is integer -%}
                inst.operand({{part}})
            {%- else -%}
                "{{part}}"
            {%- endif -%}
        {%- endfor %};

        {%- if info.comment|length != 0 -%}
            if (comment) {
                out 
                {%- for part in info.comment -%}
                    {%- if part is integer -%} 
                        << info.operand({{part}})
                    {%- else -%}
                        "{{part}}"
                    {%- endif -%}
                {%- endfor -%};
            }
        {%- endif -%}
    }

    uint32_t operand_num() {
        return {{info.operands|length}};
    }

    OperandFlag operand_flag(uint32_t idx) {
        switch (idx) {
            {%- for idx, op in info.operands.items() -%}
                case {{idx}}:
                    return OperandFlag{{op.flag}};
            {%- endfor -%}
            default:
                assert(false && "Invalid operand index");
        }
    }
    
    uint32_t inst_flag() {
        return InstFlagNone 
            {%- for flag in info.flag -%}
                | InstFlag{{flag}} 
            {%- endfor -%};
    }

    std::string_view name() {
        return "{{target_name}}.{{name}}";
    }

};
{% endfor %}

class {{target_name}}InstInfo final: public TargetInstInfo {
    {%- for name, info in insts.items() -%}
    {{target_name}}InstInfo{{name}} _instinfo{{name}};
    {%- endfor -%}
public:
    {{target_name}}InstInfo() = default;
    InstInfo& get_instinfo(uint32_t opcode) {
        switch (opcode) {
            {% for name, info in insts.items() -%}
            case {{target_name}}Inst::{{name}}:
                return _instinfo{{name}};
            {%- endfor %}
            default:
            assert(false && "Invalid opcode");
                // return TargetInstInfo::get_instinfo(opcode);
        }
    }
};

TargetInstInfo& get{{target_name}}InstInfo() {
    static {{target_name}}InstInfo instance;
    return instance;
}
TARGET_NAMESPACE_END
